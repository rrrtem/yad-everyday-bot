# Логика работы cron-функции (Challenge Guardian)

## Общая структура
Cron-функция отвечает за автоматическую проверку выполнения ежедневных заданий, списание жизней, постановку пользователей на паузу (is_active = false), удаление пользователей из чата и ежемесячный сброс жизней. Вся логика реализуется через одну таблицу users.

## Структура таблицы users (используемые поля)
- telegram_id (bigint) — Telegram ID пользователя (основной внешний ключ)
- is_active (boolean) — Активен ли пользователь
- current_lives (int) — Текущее количество жизней
- max_lives (int) — Максимальное количество жизней
- post_today (boolean) — Был ли сегодня пост с тегом #daily
- left_at (timestamptz) — Когда пользователь был удалён из чата
- updated_at (timestamptz) — Последнее обновление записи

## Ежедневная проверка (dailyCron)
1. Для всех пользователей:
    - Если is_active = true:
        - Если post_today = false:
            - current_lives уменьшается на 1 (но не ниже 0).
            - Если после списания current_lives стало 0:
                - is_active = false
                - left_at = now()
                - updated_at = now()
                - Пользователь удаляется из чата (если возможно) и получает сообщение о постановке на паузу.
            - Если current_lives > 0:
                - Пользователю отправляется сообщение о списании жизни и количестве оставшихся жизней.
2. После проверки у всех пользователей (включая неактивных) post_today = false (сброс на следующий день).

## Ежемесячный сброс (monthlyReset)
- В конце месяца для всех пользователей:
    - current_lives = max_lives (или дефолтное значение)
    - updated_at = now()
    - Активным пользователям отправляется личное сообщение о сбросе жизней.

## Публичное напоминание за 6 часов до дедлайна (publicDeadlineReminder)
- Функция отправляет публичное напоминание в канал для всех активных пользователей, которые не прислали пост за день.
- Конец дня считается не в 23:59, а в 02:59 следующего дня по CET (01:59 UTC).
- При вызове функции вычисляется, сколько часов и минут осталось до конца дня относительно текущего времени.
- В сообщение подставляется динамическое время: если больше часа — "До конца дня осталось X часов!"; если меньше часа — "До конца дня осталось меньше часа! (Y минут)".
- Сообщение отправляется в канал с упоминанием всех пользователей, которые не прислали пост, и с этим динамическим временем.
- Если все участники уже прислали посты, сообщение не отправляется.

**Используемые таблицы и поля:**
- Таблица: users
- Поля: username, is_active, post_today

**Ключевые переменные:**
- Конец дня: 02:59 следующего дня по CET
- Динамическое сообщение о времени до конца дня

## Эталонные переменные и сообщения
- DEFAULT_MAX_LIVES — дефолтное количество жизней (из constants.ts)
- MSG_LIFE_DEDUCTED — шаблон сообщения о списании жизни
- MSG_PAUSED — шаблон сообщения о постановке на паузу
- MSG_MONTHLY_RESET — шаблон сообщения о сбросе жизней
- CHALLENGE_JOIN_LINK — ссылка на повторное вступление

## Ключевые принципы учёта жизней
- current_lives — техническое поле, для пользователя отображается как current_lives - 2 (например, если current_lives = 4, то у пользователя 2 жизни).
- Логика переходов:
    - 4 → 3: сообщение «Осталось 2 жизни»
    - 3 → 2: сообщение «Осталась 1 жизнь»
    - 2 → 1: сообщение «Осталась последняя жизнь»
    - 1 → 0: постановка на паузу (is_active = false)
- Все сообщения о количестве жизней используют формулу (current_lives - 2) и корректное склонение.

## Принципы
- Все действия отражаются только в таблице users.
- Все операции идут по telegram_id.
- Все проверки и сравнения дат выполняются в одной временной зоне (CET).
- Если бот не может удалить пользователя из чата — логируется ошибка, статус пользователя не меняется до успешного удаления.

## Следующие шаги и предложения по оптимизации

### Следующие шаги
1. Удалить penalty_deadline из базы и кода.
2. Проверить, что penalty_active корректно выставляется и сбрасывается в dailyCron и при #paid.
3. Добавить тесты на сценарии перехода жизней и штрафов.
4. Вынести все сообщения и параметры в constants.ts.

### Предложения по оптимизации
- Использовать batch-операции для массового обновления пользователей.
- Внедрить кэширование промежуточных результатов (например, списков пользователей для рассылок).
- Перевести тяжёлые операции (например, массовые рассылки и проверки) в асинхронные задачи.
- Оптимизировать SQL-запросы: добавить индексы по часто используемым полям (is_active, penalty_active, post_today).
- Вынести все переменные, связанные с лимитами, таймерами и шаблонами сообщений, в constants.ts. 