# Логика работы функции бота (Challenge Guardian)

## Общая структура
Бот работает как серверная функция (webhook), принимает POST-запросы от Telegram. Вся логика реализуется через одну таблицу users. Все действия с пользователями, постами и жизнями отражаются только в этой таблице.

## Структура таблицы users
- user_id (bigint) — внутренний идентификатор пользователя (PRIMARY KEY, может быть serial/bigserial)
- telegram_id (bigint) — Telegram ID пользователя (обязательное поле, используется для всех операций)
- first_name (text) — Имя
- last_name (text) — Фамилия
- username (text) — Telegram username
- is_active (boolean) — Активен ли пользователь
- current_lives (int) — Текущее количество жизней
- max_lives (int) — Максимальное количество жизней
- post_today (boolean) — Был ли сегодня пост с тегом #daily
- last_post_date (date) — Дата последнего поста с тегом #daily
- left_at (timestamptz) — Когда пользователь был удалён из чата
- joined_at (timestamptz) — Когда пользователь присоединился
- updated_at (timestamptz) — Последнее обновление записи

## Основные сценарии и обновление полей

### 1. Регистрация/Актуализация пользователя
- Если пользователь пишет боту команду /start (в личку или в чат), бот отправляет приветственное сообщение с инструкцией и ссылкой на вступление (текст берётся из MSG_START в constants.ts).
- Это сообщение содержит ссылку на вступление в челлендж и просьбу написать боту в личку для получения уведомлений.
- Если пользователь не писал боту в личку ранее, Telegram не позволит боту отправить сообщение (ограничение платформы). В этом случае пользователь должен сам начать диалог с ботом.
- После команды /start бот может отправлять личные сообщения этому пользователю.
- При запуске команды /update или при присоединении нового пользователя к чату, а также при получении команды /start в личку:
  - Если пользователя нет в БД (по telegram_id) — создаётся новая запись с начальными значениями (current_lives = max_lives, is_active = true, joined_at = now(), telegram_id = ...).
  - Если пользователь есть — обновляются is_active = true, first_name, last_name, username.
- Если пользователь покинул чат (или был удалён), is_active = false и left_at = now().
- Если пользователь возвращается в чат после удаления (is_active = false, left_at заполнено):
  - is_active = true
  - left_at = null
  - joined_at не меняется
  - current_lives сохраняется (сохраняется текущее состояние)
  - first_name, last_name, username обновляются

### 2. Учёт поста с тегом #daily
- Когда бот видит сообщение с тегом #daily:
  - Если пользователь найден (по telegram_id):
    - Если post_today = true (уже был пост сегодня):
      - Повторный пост игнорируется, last_post_date не обновляется, но реакция ставится.
    - Если post_today = false:
      - post_today = true
      - last_post_date = текущая дата
      - updated_at = now()
      - отправляет личное сообщние пользователю «все принято».
  - Если пользователь не найден — создаёт новую запись с начальными значениями (current_lives = max_lives, is_active = true, joined_at = now(), telegram_id = ...), а также:
    - post_today = true
    - last_post_date = текущая дата
    - updated_at = now()
    - Ставит эмодзи-реакцию на это сообщение.
- Если сообщение с тегом #daily пришло в личку боту, а не в чат — игнорировать.

### 3. Получение ID чата (/get)
- Если пользователь отправляет команду /get в любой чат (группу или личку), бот отвечает сообщением с ID этого чата.
- Ответ формируется с помощью шаблона MSG_GET_CHAT_ID из constants.ts.
- Ответ отправляется в тот же чат, где была вызвана команда.
- Для форматирования используется parse_mode: HTML.
- Команда не взаимодействует с базой данных и не изменяет никаких данных пользователя.

## Валидация и ответы
- На все запросы Telegram возвращается 200 OK с { ok: true }.
- Если запрос не POST — возвращается 405.
- Если невалидный JSON — возвращается 400.
- Все проверки и сравнения дат должны выполняться в одной временной зоне (желательно CET).

## Принципы
- Все действия с пользователем отражаются только в таблице users.
- Нет отдельных таблиц для постов, штрафов, логов.
- Все поля и их значения должны соответствовать schema.md.
- Все операции с пользователем должны идти по telegram_id, user_id — только внутренний ключ.

## Файлы
- index.ts — точка входа, роутинг событий
- postHandler.ts — обработка постов с #daily
- userHandler.ts — работа с пользователями

## Ключевые принципы учёта жизней
- current_lives — техническое поле, для пользователя отображается как current_lives - 2 (например, если current_lives = 4, то у пользователя 2 жизни).
- Логика переходов:
    - 4 → 3: сообщение «Осталось 2 жизни»
    - 3 → 2: сообщение «Осталась 1 жизнь»
    - 2 → 1: сообщение «Осталась последняя жизнь»
    - 1 → 0: постановка на паузу (is_active = false)
- Все сообщения о количестве жизней используют формулу (current_lives - 2) и корректное склонение.

## Следующие шаги и предложения по оптимизации

### Следующие шаги
1. Проверить, что penalty_active корректно выставляется и сбрасывается в dailyCron и при #paid.
2. Добавить тесты на сценарии перехода жизней и штрафов.
3. Вынести все сообщения и параметры в constants.ts.

### Предложения по оптимизации
- Использовать batch-операции для массового обновления пользователей (например, при сбросе жизней).
- Внедрить кэширование часто используемых данных (например, профилей пользователей) для снижения нагрузки на базу данных.
- Перевести обработку тяжёлых операций (например, массовые рассылки) в асинхронные задачи.
- Оптимизировать структуру таблицы users: добавить индексы по telegram_id и is_active для ускорения выборок.
- Вынести все переменные, связанные с лимитами, таймерами и шаблонами сообщений, в constants.ts. 